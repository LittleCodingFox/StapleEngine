using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;

namespace Staple
{
    [Generator]
    public class TypeCacheRegistrationGenerator : ISourceGenerator
    {
        private readonly string[] blacklistedNamespaces =
        [
            "MessagePack",
            "NAudio",
            "JoltPhysicsSharp",
            "NVorbis",
            "GLFW",
            "SDL2",
            "Bgfx",
            "DrLibs",
            "OpenAL",
            "Newtonsoft",
            "NUnit",
            "NuGet",
        ];

        public void Initialize(GeneratorInitializationContext context)
        {
            /*
            if(!Debugger.IsAttached)
            {
                Debugger.Launch();
            }
            */
        }

        public void Execute(GeneratorExecutionContext context)
        {
            var source = $@"// <auto-generated />
using System;

namespace Staple
{{
    public static class TypeCacheRegistration
    {{
        public static void RegisterAll()
        {{
            TypeCache.Clear();
";

            var types = new HashSet<string>();

            void Perform(IAssemblySymbol symbol, bool isSelf)
            {
                void HandleNamedSymbol(INamedTypeSymbol t, string baseTypeName)
                {
                    if (t.IsAbstract || t.IsGenericType || t.Name.EndsWith("Attribute") ||
                        t.GetAttributes().Any(x => x.AttributeClass.Name == typeof(RequiredAttributeAttribute).Name ||
                        x.AttributeClass.Name == typeof(ObsoleteAttribute).Name) ||
                        (t.DeclaredAccessibility != Accessibility.Public &&
                        (t.DeclaredAccessibility != Accessibility.Internal || isSelf == false)))
                    {
                        //source += $"            //Ignoring type {t.Name}: {t.DeclaredAccessibility}\r\n";

                        return;
                    }

                    var typeName = baseTypeName.Length == 0 ? t.Name : $"{baseTypeName}.{t.Name}";

                    Debug.WriteLine($"Adding type {typeName}");

                    if (typeName.Contains("e__FixedBuffer"))
                    {
                        //source += $"            //Processing to {typeName}. Skipped (FixedBuffer)\r\n";

                        return;
                    }

                    if (typeName.ToUpperInvariant().Contains("DELEGATE"))
                    {
                        //source += $"            //Processing to {typeName}. Skipped (Delegate)\r\n";

                        return;
                    }

                    types.Add(typeName);

                    foreach(var member in t.GetMembers().Where(x => x.Kind == SymbolKind.Field))
                    {
                        HandleSymbol(member);
                    }

                    foreach (var type in t.GetTypeMembers())
                    {
                        HandleNamedSymbol(type, $"{baseTypeName}.{t.Name}");
                    }
                }

                void HandleSymbol(ISymbol t)
                {
                    if (t.IsAbstract || t.Name.EndsWith("Attribute") ||
                        t.GetAttributes().Any(x => x.AttributeClass.Name == typeof(RequiredAttributeAttribute).Name ||
                        x.AttributeClass.Name == typeof(ObsoleteAttribute).Name) ||
                        (t.DeclaredAccessibility != Accessibility.Public &&
                        (t.DeclaredAccessibility != Accessibility.Internal || isSelf == false)))
                    {
                        //source += $"            //Ignoring type {t.Name}: {t.DeclaredAccessibility}\r\n";

                        return;
                    }

                    Debug.WriteLine($"Entering type {t.Name}");

                    //source += $"            //Entering type: {t.Name}\r\n";

                    void HandleTypeSymbol(ITypeSymbol symbol)
                    {
                        var displayFormat = new SymbolDisplayFormat(SymbolDisplayGlobalNamespaceStyle.Omitted,
                            SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
                            SymbolDisplayGenericsOptions.IncludeTypeParameters);

                        var typeName = symbol.ToDisplayString(NullableFlowState.None, displayFormat);

                        if(typeName.EndsWith("*"))
                        {
                            //source += $"            //Resolved to {typeName}. Skipped (pointer)\r\n";

                            return;
                        }

                        if(typeName.StartsWith("MessagePack"))
                        {
                            //source += $"            //Resolved to {typeName}. Skipped (MessagePack)\r\n";

                            return;
                        }

                        if(typeName.Contains("e__FixedBuffer"))
                        {
                            //source += $"            //Resolved to {typeName}. Skipped (FixedBuffer)\r\n";

                            return;
                        }

                        if (typeName.ToUpperInvariant().Contains("DELEGATE"))
                        {
                            //source += $"            //Processing to {typeName}. Skipped (Delegate)\r\n";

                            return;
                        }

                        Debug.WriteLine($"Resolved to {typeName}");

                        //source += $"            //Resolved to {typeName}\r\n";
                        types.Add(typeName);
                    }

                    if (t is IFieldSymbol field)
                    {
                        HandleTypeSymbol(field.Type);
                    }
                    else if(t is IPropertySymbol property)
                    {
                        HandleTypeSymbol(property.Type);
                    }
                }

                void HandleNamespace(INamespaceSymbol n)
                {
                    if (n.Name == "System" || n.Name == "Microsoft")
                    {
                        return;
                    }

                    var namespaceName = n.Name;

                    void Name(INamespaceSymbol s)
                    {
                        if(s == null || s.Name.Length == 0)
                        {
                            return;
                        }

                        namespaceName = $"{s.Name}.{namespaceName}";

                        if(s.ContainingNamespace != null)
                        {
                            Name(s.ContainingNamespace);
                        }
                    }

                    Name(n.ContainingNamespace);

                    foreach (var t in n.GetTypeMembers())
                    {
                        HandleNamedSymbol(t, namespaceName);
                    }

                    foreach (var ns in n.GetNamespaceMembers())
                    {
                        HandleNamespace(ns);
                    }
                }

                foreach (var n in symbol.GlobalNamespace.GetNamespaceMembers())
                {
                    HandleNamespace(n);
                }

                HandleNamespace(symbol.GlobalNamespace);
            }

            foreach (var symbol in context.Compilation.SourceModule.ReferencedAssemblySymbols)
            {
                Perform(symbol, false);
            }

            Perform(context.Compilation.SourceModule.ContainingAssembly, true);

            foreach(var type in types)
            {
                if(type.StartsWith("System.") && !type.StartsWith("System.Collections"))
                {
                    continue;
                }

                bool skip = false;

                foreach(var item in blacklistedNamespaces)
                {
                    if(type.StartsWith($"{item}."))
                    {
                        skip = true;

                        break;
                    }
                }

                if(skip)
                {
                    continue;
                }

                //source += $"            Console.WriteLine(\"Registering {type}\");\r\n\r\n";
                source += $"            TypeCache.RegisterType(typeof({type}));\r\n";
            }

            source += $@"
        }}
    }}
}}";

            context.AddSource("TypeCacheRegistration.Generated.cs", SourceText.From(source, Encoding.UTF8));
        }
    }
}
